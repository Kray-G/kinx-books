
# 名前空間・クラス・モジュール
## 名前空間

### 名前空間オブジェクト

キーワード `namespace` を使用して、名前空間を使用可能です。

名前空間は **オブジェクト** であり、
名前空間内で宣言されたクラス、モジュールは名前空間オブジェクトに設定されます。
ただし、定数等は名前空間オブジェクトには自動的に設定されないため、自分で設定する必要があります。

```javascript
namespace N {
    class A {
        ...
    }

    const X = 10;
    N.X = 100;

    var a = new A(); // OK
    ...
}

// var a = new A(); // エラー
var a = new N.A(); // OK

// System.println(X); // エラー
System.println(N.X); // OK
```

名前空間はネストできます。

```javascript
namespace A {
namespace B {

    class X { ... }

} // namespace B

    var x = new B.X(); // OK

} // namespace A

var x = new A.B.X(); // OK
```

## クラス
### クラスとは
### クラスの定義
### サブクラスと継承

## モジュール
### モジュールとは
### モジュールの定義
### ミックスイン

## 演算子オーバーライド

### 演算子オーバーライドとは

オブジェクトに対する演算子の挙動を上書きすることを言います。
演算子がクラスに属しているメソッドと考えれば「オーバーライド」となり、クラスに属さないと考えると「オーバーロード」となるイメージですが、
ここでは Ruby のように演算子はクラス・オブジェクトへのメッセージであり、クラスに属しているイメージで考え、
そのクラス・メソッドを上書きする形を表現して「オーバーライド」で統一しておきます[^overload]。

[^overload]: C++ の演算子オーバーロードは演算子の多重定義を意味します。
クラス・メソッドではなく、同じ名前の関数（や演算子）でも、その引数の違いによって呼び出される関数が区別される機能のことです。

### 基本形

オーバーライド可能な演算子の種類は以下の通りです。

* `==`、`!=`、`>`、`>=`、`<`、`<=`、`<=>`、`<<`、`>>`、`+`、`-`、`*`、`/`、`%`、`[]`、`()`.

例として、`+` 演算子をオーバーライドしてみましょう。
関数名を演算子名の `+` とするだけです。
他の演算子でも同じです。

```javascript
class Sample(value_) {
    @isSample = true;
    @value = value_;
    public +(rhs) {
        if (rhs.isSample) {
            return new Sample(value_ + rhs.value);
        }
        return new Sample(value_ + rhs);
    }
}
```

`rhs` として渡されるものは、適宜想定するコンテキストに合わせて場合分けして実装する必要があります。
先の例のように実装すると、以下のように使えるようになります。

```javascript
var s1 = new Sample(10);
var s2 = s1 + 100;
s1 += 1100;
System.println(s1.value);  // => 1110
System.println(s2.value);  // => 110
```

`a += b` も内部的には `a = a + b` に展開されるので正しく動作します。

尚、オブジェクトに対するメソッド呼び出しなので、次のようにも書けます。

```javascript
var s1 = new Sample(10);
var s2 = s1.+(100);
System.println(s2.value);  // => 110
```

基本的に、`[]` 演算子と `()` 演算子以外の右辺値を取る演算子は、同様の動作をします。

### `[]` 演算子

`[]` はインデックス要素的なアクセスを許可します。
ただし、インデックスには整数（Integer）かオブジェクト、または配列しか使えません。
実数（Double）は動作しますが引数には整数（Integer）で渡されます。
文字列は、プロパティ・アクセスと同じであり、無限ループする可能性があるため使えません。

実際に、例えば `Range` には実装されており、以下のようなアクセスが可能です。

```javascript
System.println((2..10)[1]);
System.println(('b'..'z')[1]);
```

```console
3
c
```

`[]` 演算子もメソッド呼び出し風に書くと以下のようになります。

```javascript
System.println((2..10).[](1));     // => 3
System.println(('b'..'z').[](1));  // => 'c'
```

### `()` 演算子

`()` 演算子はオブジェクトに直接作用します。
C++ のファンクタ（`operator()` を定義したクラス）のような振る舞いをします。
例えば以下のようにクラス・インスタンスを関数のように見立てて直接 `()` 演算子を適用できます。

```javascript
class Functor {
    public ()(...a) {
        return System.println(a);
    }
}

var f = new Functor();
f(1, 2, 3, 4, 5, 6, 7);
```

```console
[1, 2, 3, 4, 5, 6, 7]
```

メソッド呼び出し風に書くと以下と同じです。

```javascript
var f = new Functor();
f.()(1, 2, 3, 4, 5, 6, 7);
```

```console
[1, 2, 3, 4, 5, 6, 7]
```

